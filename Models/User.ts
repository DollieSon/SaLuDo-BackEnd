// =======================
// USER MODEL
// =======================
// Purpose: Authentication and authorization for HR staff
// Collections: users (MongoDB)
// Related: No direct relationship to Candidate (Users manage Candidates)
// =======================

import { UserRole, UserRoleHierarchy } from './enums/UserRole';
import {
  UserData,
  CreateUserData,
  UpdateUserData,
  UserProfile,
  UserLoginData,
  UserAuthTokens,
} from './interfaces/UserInterfaces';

// Re-export for convenience
export { UserRole, UserRoleHierarchy } from './enums/UserRole';
export { hasPermission, getRoleDisplayName } from './enums/UserRole';
export * from './interfaces/UserInterfaces';

// =======================
// USER CLASS
// =======================

export class User {
  public userId: string;
  public email: string;
  public passwordHash: string;
  public firstName: string;
  public middleName?: string;
  public lastName: string;
  public title: string;
  public role: UserRole;
  public isActive: boolean;
  public isVerified: boolean;
  public isDeleted: boolean;
  public createdAt: Date;
  public updatedAt: Date;
  public lastLogin?: Date;
  public refreshToken?: string;
  public passwordResetToken?: string;
  public passwordResetExpires?: Date;
  // Security fields
  public mustChangePassword: boolean;
  public failedLoginAttempts: number;
  public accountLockedUntil?: Date;
  public passwordChangedAt?: Date;
  public passwordHistory?: string[];

  constructor(
    email: string,
    passwordHash: string,
    firstName: string,
    lastName: string,
    title: string,
    role: UserRole,
    middleName?: string,
    userId?: string,
    createdAt?: Date,
    updatedAt?: Date
  ) {
    // userId is generated by UserRepository using MongoDB ObjectId
    // If not provided, it will be set by the repository layer
    this.userId = userId || '';
    this.email = email;
    this.passwordHash = passwordHash;
    this.firstName = firstName;
    this.middleName = middleName;
    this.lastName = lastName;
    this.title = title;
    this.role = role;
    this.isActive = true;
    this.isVerified = false;
    this.isDeleted = false;
    this.createdAt = createdAt || new Date();
    this.updatedAt = updatedAt || new Date();
    // Initialize security fields
    this.mustChangePassword = true; // Default: require password change for new accounts
    this.failedLoginAttempts = 0;
  }

  // =======================
  // PROFILE METHODS
  // =======================

  getFullName(): string {
    if (this.middleName) {
      return `${this.firstName} ${this.middleName} ${this.lastName}`;
    }
    return `${this.firstName} ${this.lastName}`;
  }

  getProfile(): UserProfile {
    return {
      userId: this.userId,
      email: this.email,
      firstName: this.firstName,
      middleName: this.middleName,
      lastName: this.lastName,
      fullName: this.getFullName(),
      title: this.title,
      role: this.role,
      isActive: this.isActive,
      isVerified: this.isVerified,
      createdAt: this.createdAt,
      lastLogin: this.lastLogin,
    };
  }

  // =======================
  // ACCOUNT STATUS METHODS
  // =======================

  activate(): void {
    this.isActive = true;
    this.updatedAt = new Date();
  }

  deactivate(): void {
    this.isActive = false;
    this.updatedAt = new Date();
  }

  verify(): void {
    this.isVerified = true;
    this.updatedAt = new Date();
  }

  softDelete(): void {
    this.isDeleted = true;
    this.isActive = false;
    this.updatedAt = new Date();
  }

  recordLogin(): void {
    this.lastLogin = new Date();
    this.updatedAt = new Date();
  }

  // =======================
  // PERMISSION METHODS
  // =======================

  hasPermission(requiredRole: UserRole): boolean {
    return UserRoleHierarchy[this.role] >= UserRoleHierarchy[requiredRole];
  }

  isAdmin(): boolean {
    return this.role === UserRole.ADMIN;
  }

  isHRManager(): boolean {
    return this.role === UserRole.HR_MANAGER || this.isAdmin();
  }

  canManageCandidates(): boolean {
    return this.role !== UserRole.INTERVIEWER;
  }

  canManageJobs(): boolean {
    return this.isHRManager();
  }

  canManageUsers(): boolean {
    return this.isAdmin();
  }

  // =======================
  // TOKEN METHODS
  // =======================

  setRefreshToken(token: string): void {
    this.refreshToken = token;
    this.updatedAt = new Date();
  }

  clearRefreshToken(): void {
    this.refreshToken = undefined;
    this.updatedAt = new Date();
  }

  setPasswordResetToken(token: string, expiresInHours: number = 1): void {
    this.passwordResetToken = token;
    this.passwordResetExpires = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);
    this.updatedAt = new Date();
  }

  clearPasswordResetToken(): void {
    this.passwordResetToken = undefined;
    this.passwordResetExpires = undefined;
    this.updatedAt = new Date();
  }

  isPasswordResetTokenValid(): boolean {
    if (!this.passwordResetToken || !this.passwordResetExpires) {
      return false;
    }
    return this.passwordResetExpires > new Date();
  }

  // =======================
  // ACCOUNT SECURITY METHODS
  // =======================

  requirePasswordChange(): void {
    this.mustChangePassword = true;
    this.updatedAt = new Date();
  }

  clearPasswordChangeRequirement(): void {
    this.mustChangePassword = false;
    this.updatedAt = new Date();
  }

  recordPasswordChange(newPasswordHash: string, maxPasswordHistory: number = 5): void {
    // Initialize password history if it doesn't exist
    if (!this.passwordHistory) {
      this.passwordHistory = [];
    }

    // Add current password to history
    this.passwordHistory.unshift(this.passwordHash);

    // Limit password history to maxPasswordHistory entries
    if (this.passwordHistory.length > maxPasswordHistory) {
      this.passwordHistory = this.passwordHistory.slice(0, maxPasswordHistory);
    }

    // Update password and clear change requirement
    this.passwordHash = newPasswordHash;
    this.passwordChangedAt = new Date();
    this.mustChangePassword = false;
    this.updatedAt = new Date();
  }

  isPasswordInHistory(passwordHash: string): boolean {
    if (!this.passwordHistory || this.passwordHistory.length === 0) {
      return false;
    }
    return this.passwordHistory.includes(passwordHash);
  }

  incrementFailedLoginAttempts(maxAttempts: number = 5, lockoutMinutes: number = 30): void {
    this.failedLoginAttempts++;
    
    // Lock account if max attempts exceeded
    if (this.failedLoginAttempts >= maxAttempts) {
      this.accountLockedUntil = new Date(Date.now() + lockoutMinutes * 60 * 1000);
      this.isActive = false;
    }
    
    this.updatedAt = new Date();
  }

  resetFailedLoginAttempts(): void {
    this.failedLoginAttempts = 0;
    this.accountLockedUntil = undefined;
    this.updatedAt = new Date();
  }

  isAccountLocked(): boolean {
    if (!this.accountLockedUntil) {
      return false;
    }
    
    const now = new Date();
    const isLocked = this.accountLockedUntil > now;
    
    // Auto-unlock if lockout period has passed
    if (!isLocked && this.failedLoginAttempts > 0) {
      this.resetFailedLoginAttempts();
      this.isActive = true;
    }
    
    return isLocked;
  }

  unlockAccount(): void {
    this.failedLoginAttempts = 0;
    this.accountLockedUntil = undefined;
    this.isActive = true;
    this.updatedAt = new Date();
  }

  // =======================
  // UTILITY METHODS
  // =======================

  toObject(): UserData {
    return {
      userId: this.userId,
      email: this.email,
      passwordHash: this.passwordHash,
      firstName: this.firstName,
      middleName: this.middleName,
      lastName: this.lastName,
      title: this.title,
      role: this.role,
      isActive: this.isActive,
      isVerified: this.isVerified,
      isDeleted: this.isDeleted,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      lastLogin: this.lastLogin,
      refreshToken: this.refreshToken,
      passwordResetToken: this.passwordResetToken,
      passwordResetExpires: this.passwordResetExpires,
      mustChangePassword: this.mustChangePassword,
      failedLoginAttempts: this.failedLoginAttempts,
      accountLockedUntil: this.accountLockedUntil,
      passwordChangedAt: this.passwordChangedAt,
      passwordHistory: this.passwordHistory,
    };
  }

  static fromObject(data: UserData): User {
    const user = new User(
      data.email,
      data.passwordHash,
      data.firstName,
      data.lastName,
      data.title,
      data.role,
      data.middleName,
      data.userId,
      data.createdAt,
      data.updatedAt
    );

    user.isActive = data.isActive;
    user.isVerified = data.isVerified;
    user.isDeleted = data.isDeleted;
    user.lastLogin = data.lastLogin;
    user.refreshToken = data.refreshToken;
    user.passwordResetToken = data.passwordResetToken;
    user.passwordResetExpires = data.passwordResetExpires;
    user.mustChangePassword = data.mustChangePassword;
    user.failedLoginAttempts = data.failedLoginAttempts;
    user.accountLockedUntil = data.accountLockedUntil;
    user.passwordChangedAt = data.passwordChangedAt;
    user.passwordHistory = data.passwordHistory;

    return user;
  }
}
